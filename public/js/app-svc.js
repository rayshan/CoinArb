// Generated by CoffeeScript 1.7.1
(function() {
  var svc;

  svc = angular.module('CaAppSvc', ['ngResource', 'btford.socket-io', 'poller']);

  svc.factory('caNotificationSvc', function() {
    return {
      enabled: false,
      create: function(data) {
        var n;
        if (Notification.permission === !'granted') {
          Notification.requestPermission();
        }
        n = new Notification('yo', {
          body: data
        });
      }
    };
  });

  svc.factory('caCheckAndCopySvc', function($rootScope, exchangeSvc, caNotificationSvc) {
    return {
      process: function(id, current) {
        var changed, data, now;
        now = moment();
        data = exchangeSvc.data[id].fetched;
        if (data.initialized === false) {
          data.initialized = true;
          current.updateTime = now;
          data.current = {};
          angular.copy(current, data.current);
          if (caNotificationSvc.enabled) {
            caNotificationSvc.create(exchangeSvc.data[id].fetched.current.last);
          }
          $rootScope.$broadcast("tickerUpdate");
        } else {
          changed = current.last !== data.current.last || current.spread !== data.current.spread;
          if (changed) {
            current.updateTime = now;
            if (data.previous == null) {
              data.previous = {};
            }
            angular.copy(data.current, data.previous);
            angular.copy(current, data.current);
            if (caNotificationSvc.enabled) {
              caNotificationSvc.create(exchangeSvc.data[id].fetched.current.last);
            }
            $rootScope.$broadcast("tickerUpdate");
          }
        }
      }
    };
  });

  svc.factory('caTickerSvc', function($resource, $filter, poller, caSocketSvc, exchangeSvc, caCheckAndCopySvc) {
    var USDCNY, data, errorCb, myResource, name, notifyCb, pollers, _i, _len, _ref;
    USDCNY = 6.05;
    pollers = [];
    notifyCb = function(id) {
      return function(res) {
        var current;
        switch (id) {
          case "btcchina":
            current = {
              last: $filter('round')(res.ticker.last / USDCNY),
              spread: $filter('round')((res.ticker.buy - res.ticker.sell) / USDCNY)
            };
            caCheckAndCopySvc.process(id, current);
            break;
          case "mtgox":
            current = {
              last: $filter('round')(res.data.last.value),
              spread: $filter('round')(res.data.buy.value - res.data.sell.value)
            };
            caCheckAndCopySvc.process(id, current);
            break;
          case "btce":
            current = {
              last: $filter('round')(res.query.results.ticker.last),
              spread: $filter('round')(res.query.results.ticker.buy - res.query.results.ticker.sell)
            };
            caCheckAndCopySvc.process(id, current);
            break;
          case "bitfinex":
            current = {
              last: $filter('round')(res.query.results.json.last_price),
              spread: $filter('round')(res.query.results.json.bid - res.query.results.json.ask)
            };
            caCheckAndCopySvc.process(id, current);
            break;
          case "localbitcoins":
            current = {
              last: $filter('round')(res.query.results.json.USD.avg_3h)
            };
            caCheckAndCopySvc.process(id, current);
            break;
          default:
            current = {
              last: $filter('round')(res[id].rates.last),
              spread: $filter('round')(res[id].rates.bid - res[id].rates.ask)
            };
            caCheckAndCopySvc.process(id, current);
        }
      };
    };
    errorCb = function(reason) {
      throw "poller or resource failed";
      console.log(reason);
    };
    _ref = exchangeSvc.data;
    for (name in _ref) {
      data = _ref[name];
      if (data.api.type === "REST") {
        myResource = $resource(data.api.uri);
        pollers.push({
          id: name,
          item: poller.get(myResource, {
            action: 'get',
            delay: data.api.rateLimit
          })
        });
      } else {
        caSocketSvc.process(data);
      }
    }
    for (_i = 0, _len = pollers.length; _i < _len; _i++) {
      poller = pollers[_i];
      poller.item.promise.then(null, errorCb, notifyCb(poller.id));
    }
  });

  svc.factory('caSocketSvc', function($rootScope, $filter, socketFactory, caCheckAndCopySvc) {
    var unsubscribe;
    unsubscribe = {
      depthBTCUSD: {
        op: 'unsubscribe',
        channel: '24e67e0d-1cad-4cc0-9e7a-f8523ef460fe'
      },
      tradeBTC: {
        op: 'unsubscribe',
        channel: 'dbf1dee9-4f2e-4a08-8cb7-748919a71b21'
      }
    };
    return {
      process: function(data) {
        var channel, obj, socket;
        socket = socketFactory({});
        socket.forward('error');
        for (channel in unsubscribe) {
          obj = unsubscribe[channel];
          socket.send(JSON.stringify(obj));
        }
        socket.on("message", function(res) {
          var current;
          if (res.op.indexOf("subscribe") === -1 && res.channel_name.indexOf("ticker") !== -1) {
            current = {
              spread: $filter('round')(res.ticker.buy.value - res.ticker.sell.value),
              last: $filter('round')(res.ticker.last.value),
              updateTime: null,
              error: null
            };
            caCheckAndCopySvc.process(data.id, current);
          }
        });
        socket.on("socket:error", function(event, data) {
          throw "socket failed";
          console.log(event);
          console.log(data);
        });
      }
    };
  });

}).call(this);

//# sourceMappingURL=app-svc.map
